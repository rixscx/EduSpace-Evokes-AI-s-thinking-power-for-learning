
'use server';
/**
 * @fileOverview Generates a final comprehensive quiz for a course.
 * The quiz aims for 30 total marks and is based on the entire course content.
 *
 * - generateFinalCourseQuiz - Main function to generate the quiz.
 * - GenerateFinalCourseQuizInput - Input type (courseId).
 * - GenerateFinalCourseQuizOutput - Output type (structured quiz data).
 */

import {ai} from '@/ai/genkit';
import {z} from 'genkit';
import { getCourseById } from '@/lib/mockCourses';
import type { Course, Module, Chapter, ContentBlock, QuizQuestion, QuizQuestionType, FinalQuizData } from '@/types/platform';

const GenerateFinalCourseQuizInputSchema = z.object({
  courseId: z.string().describe('The ID of the course for which to generate the quiz.'),
  cacheBuster: z.string().optional().describe('A random string to ensure a unique quiz is generated each time.'),
});
export type GenerateFinalCourseQuizInput = z.infer<typeof GenerateFinalCourseQuizInputSchema>;

// Schema for individual questions to be generated by AI
const QuizQuestionOutputSchema = z.object({
  id: z.string().describe("A unique ID for this question (e.g., 'q1', 'q2')."),
  questionText: z.string().describe('The full text of the quiz question.'),
  questionType: z.enum(['mcq', 'true_false', 'fill_in_the_blank'] as [QuizQuestionType, ...QuizQuestionType[]]).default('mcq').describe("The type of question. Default to 'mcq' if not specified otherwise."),
  options: z.array(z.string()).optional().describe('For MCQ: An array of 4 distinct answer options.'),
  correctAnswerIndex: z.number().min(0).max(3).optional().describe('For MCQ: The 0-based index of the correct answer in the options array.'),
  marks: z.number().min(1).max(5).default(2).describe('Marks allocated for this question (e.g., 2 or 3 marks).'),
});

const GenerateFinalCourseQuizOutputSchema = z.object({
  quizTitle: z.string().describe("A suitable title for this final quiz (e.g., 'Final Assessment: [Course Title]')."),
  questions: z.array(QuizQuestionOutputSchema).min(10).max(20).describe("An array of 10-15 quiz questions. The total marks should aim to be around 30."),
  totalMarks: z.number().describe("The sum of marks for all questions in the quiz, should be around 30."),
});
export type GenerateFinalCourseQuizOutput = z.infer<typeof GenerateFinalCourseQuizOutputSchema>;


function extractTextContentFromCourse(course: Course): string {
  let content = `Course Title: ${course.title}\nCourse Description: ${course.description}\n\n`;
  course.modules.forEach((module: Module) => {
    content += `Module: ${module.title}\n${module.description ? `Description: ${module.description}\n` : ''}\n`;
    module.chapters.forEach((chapter: Chapter) => {
      content += `  Chapter: ${chapter.title}\n`;
      chapter.contentBlocks.forEach((block: ContentBlock) => {
        if (block.type === 'heading') {
          content += `    Heading (H${block.level || 3}): ${block.value}\n`;
        } else if (block.type === 'text') {
          content += `    Text: ${block.value.replace(/<[^>]+>/g, ' ')}\n`; // Strip HTML tags
        }
      });
      content += '\n';
    });
    content += '\n';
  });
  return content;
}

export async function generateFinalCourseQuiz(
  input: GenerateFinalCourseQuizInput
): Promise<FinalQuizData> {
  const course = await getCourseById(input.courseId);
  if (!course) {
    throw new Error(`Course with ID ${input.courseId} not found.`);
  }

  const courseTextContent = extractTextContentFromCourse(course);

  const result = await generateQuizFlow({ courseId: input.courseId, courseContent: courseTextContent, courseTitle: course.title, cacheBuster: input.cacheBuster });

  // Ensure question IDs are unique if AI doesn't guarantee it.
  const validatedQuestions = result.questions.map((q, index) => ({
      ...q,
      id: q.id || `q_final_${index + 1}_${Date.now()}`, // Ensure unique ID
      questionType: 'mcq', // Forcing MCQ for now
  }));

  // Recalculate total marks based on actual generated questions' marks
  const finalTotalMarks = validatedQuestions.reduce((sum, q) => sum + (q.marks || 2), 0);

  return {
      quizTitle: result.quizTitle || `Final Quiz for ${course.title}`,
      questions: validatedQuestions,
      totalMarks: finalTotalMarks
  };
}

const promptInputSchema = z.object({
  courseId: z.string(),
  courseContent: z.string(),
  courseTitle: z.string(),
  cacheBuster: z.string().optional(),
});

const prompt = ai.definePrompt({
  name: 'generateFinalCourseQuizPrompt',
  input: {schema: promptInputSchema},
  output: {schema: GenerateFinalCourseQuizOutputSchema},
  prompt: `
    You are an expert instructional designer tasked with creating a comprehensive final assessment quiz for an online course.
    The quiz should rigorously test the student's understanding of the entire course material provided.

    Course Title: "{{courseTitle}}"
    Full Course Content (Textual Summary):
    \`\`\`
    {{{courseContent}}}
    \`\`\`

    **Quiz Requirements:**
    1.  **Quiz Title:** Create an appropriate title for this final assessment (e.g., "Final Assessment: {{courseTitle}}").
    2.  **Number of Questions:** Generate between 10 and 15 questions.
    3.  **Question Type:** For this version, ALL questions MUST be Multiple Choice Questions (MCQs). Create challenging questions that require understanding and application of concepts, not just simple recall of facts.
    4.  **MCQ Options:** Each MCQ must have exactly 4 distinct and plausible answer options.
    5.  **Correct Answer & Randomization:** Clearly indicate the 0-based index of the single correct answer for each MCQ. It is CRITICAL that you randomize the position of the correct answer. Do not consistently make the first option (index 0) the correct one. Distribute the correct answer across all possible indices (0, 1, 2, 3).
    6.  **Marks per Question:** Assign marks to each question, typically 2 or 3 marks per question. The sum of marks for all questions should aim to be approximately 30.
    7.  **Unique ID per Question:** Assign a simple, unique ID to each question (e.g., "q1", "q2_topicA", etc.).
    8.  **Content Coverage:** Questions should cover a broad range of topics from the provided course content, from foundational concepts to more advanced details if present.
    9.  **Clarity and Uniqueness:** Ensure questions are clear, unambiguous, and distinct from one another. Avoid trick questions.
    10. **Uniqueness on Retake:** It is critical that each time this prompt is run, it produces a UNIQUE and DIFFERENT set of questions from any previous generation for the same course. This request has a random seed: {{cacheBuster}}. Use this seed to ensure the question set is completely new. Do not repeat questions from previous attempts. Vary the topics covered, the question phrasing, and the specific concepts tested to ensure a fresh assessment for every attempt.

    **Output Format:**
    Strictly adhere to the JSON schema provided for the output. Ensure the generated JSON is valid. Ensure totalMarks is the sum of marks from all generated questions.
    All questions must have questionType set to "mcq".
    The options array for MCQs must contain 4 strings.
    The correctAnswerIndex must be a number between 0 and 3.
  `,
});

const generateQuizFlow = ai.defineFlow(
  {
    name: 'generateFinalCourseQuizFlow',
    inputSchema: promptInputSchema,
    outputSchema: GenerateFinalCourseQuizOutputSchema,
  },
  async (input) => {
    try {
      const {output} = await prompt(input);
      if (!output) {
        throw new Error('AI did not return quiz content.');
      }
      if (output.questions.length === 0) {
        throw new Error('AI did not generate any questions for the quiz.');
      }

      // Validate and recalculate totalMarks
      let calculatedTotalMarks = 0;
      output.questions.forEach(q => {
        if (q.questionType === 'mcq') {
          if (!q.options || q.options.length !== 4) {
            console.warn(`MCQ "${q.questionText}" does not have 4 options. Fixing/flagging.`);
            q.options = (q.options || []).slice(0,4);
            while(q.options.length < 4) q.options.push("Missing option");
          }
          if (q.correctAnswerIndex === undefined || q.correctAnswerIndex < 0 || q.correctAnswerIndex > 3) {
             console.warn(`MCQ "${q.questionText}" has invalid correctAnswerIndex. Defaulting to 0.`);
             q.correctAnswerIndex = 0;
          }
        }
        calculatedTotalMarks += q.marks || 2; // Default marks if missing
      });

      if (output.totalMarks !== calculatedTotalMarks) {
          console.warn(`AI reported totalMarks ${output.totalMarks} but calculated ${calculatedTotalMarks}. Using calculated value.`);
          output.totalMarks = calculatedTotalMarks;
      }
      if (output.totalMarks === 0 && output.questions.length > 0) {
          // If total marks is still 0, assign default marks and recalculate
          output.questions.forEach(q => q.marks = q.marks || 2);
          output.totalMarks = output.questions.reduce((sum, q) => sum + q.marks, 0);
          console.warn(`Total marks was 0, assigned default marks. New total: ${output.totalMarks}`);
      }


      return output;
    } catch (error: any) {
      console.error('Error in generateFinalCourseQuizFlow:', error);
      throw new Error(`Failed to generate final course quiz: ${error.message || 'Unknown AI error'}`);
    }
  }
);
